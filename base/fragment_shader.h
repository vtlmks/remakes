/*
 * GLSL Shader Code Embedded as C Header
 * Generated by: ../bin/shader2h
 * GLSL Version: 140
 */

const char *fragment_shader_start =
	"#version 140\n"
	"//==============================================================\n"
	"//                      SETUP FOR CRTS\n"
	"//==============================================================\n"
	"#define CRTS_TONE 1\n"
	"#define CRTS_CONTRAST 1\n"
	"#define CRTS_SATURATION 1\n"
	"//--------------------------------------------------------------\n"
	"#define CRTS_WARP 1\n"
	"//--------------------------------------------------------------\n"
	"// Try different masks\n"
	"// #define CRTS_MASK_GRILLE 1\n"
	"// #define CRTS_MASK_GRILLE_LITE 1\n"
	"// #define CRTS_MASK_NONE 1\n"
	"#define CRTS_MASK_SHADOW 1\n"
	"// --------------------------------------------------------------\n"
	"// Scanline thinness\n"
	"//  0.50 = fused scanlines\n"
	"//  0.70 = recommended default\n"
	"//  1.00 = thinner scanlines (too thin)\n"
	"#define INPUT_THIN 0.7\n"
	"//--------------------------------------------------------------\n"
	"// Horizonal scan blur\n"
	"//  -3.0 = pixely\n"
	"//  -2.5 = default\n"
	"//  -2.0 = smooth\n"
	"//  -1.0 = too blurry\n"
	"#define INPUT_BLUR -2.5\n"
	"//--------------------------------------------------------------\n"
	"// Shadow mask effect, ranges from,\n"
	"//  0.25 = large amount of mask (not recommended, too dark)\n"
	"//  0.50 = recommended default\n"
	"//  1.00 = no shadow mask\n"
	"#define INPUT_MASK 0.5\n"
	"\n"
	"// Input from vertex shader\n"
	"in vec2 frag_texture_coord;\n"
	"\n"
	"// Uniform variables\n"
	"uniform vec2 resolution;\n"
	"uniform vec2 src_image_size;\n"
	"uniform float brightness;\n"
	"uniform vec4 tone_data;\n"
	"uniform int crt_emulation;\n"
	"uniform sampler2D iChannel0;\n"
	"\n"
	"out vec4 frag_color;\n"
	"\n"
	"const float PI2 = 6.28318530717958;\n"
	"const float HALF = 0.5;\n"
	"\n"
	"#define CrtsRcpF1(x) (1.0 / (x))\n"
	"#define CrtsSatF1(x) clamp((x), 0.0, 1.0)\n"
	"\n"
	"vec3 CrtsFetch(vec2 uv) {\n"
	"	return texture(iChannel0, uv).rgb;\n"
	"}\n"
	"\n"
	"float CrtsMax3F1(float a, float b, float c) {\n"
	"	return max(a, max(b, c));\n"
	"}\n"
	"\n"
	"vec3 CrtsMask(vec2 pos, float dark) {\n"
	"#ifdef CRTS_MASK_GRILLE\n"
	"	vec3 m = vec3(dark);\n"
	"	float x = fract(pos.x * (1.0 / 3.0));\n"
	"	m.r = (x < (1.0 / 3.0)) ? 1.0 : dark;\n"
	"	m.g = (x >= (1.0 / 3.0) && x < (2.0 / 3.0)) ? 1.0 : dark;\n"
	"	m.b = (x >= (2.0 / 3.0)) ? 1.0 : dark;\n"
	"	return m;\n"
	"#endif\n"
	"\n"
	"#ifdef CRTS_MASK_GRILLE_LITE\n"
	"	vec3 m = vec3(1.0);\n"
	"	float x = fract(pos.x * (1.0 / 3.0));\n"
	"	m.r = (x < (1.0 / 3.0)) ? dark : 1.0;\n"
	"	m.g = (x >= (1.0 / 3.0) && x < (2.0 / 3.0)) ? dark : 1.0;\n"
	"	m.b = (x >= (2.0 / 3.0)) ? dark : 1.0;\n"
	"	return m;\n"
	"#endif\n"
	"\n"
	"#ifdef CRTS_MASK_NONE\n"
	"	return vec3(1.0);\n"
	"#endif\n"
	"\n"
	"#ifdef CRTS_MASK_SHADOW\n"
	"	pos.x += pos.y * 3.0;\n"
	"	vec3 m = vec3(dark);\n"
	"	float x = fract(pos.x * (1.0 / 6.0));\n"
	"	m.r = (x < (1.0 / 3.0)) ? 1.0 : dark;\n"
	"	m.g = (x >= (1.0 / 3.0) && x < (2.0 / 3.0)) ? 1.0 : dark;\n"
	"	m.b = (x >= (2.0 / 3.0)) ? 1.0 : dark;\n"
	"	return m;\n"
	"#endif\n"
	"\n"
	"	// Default case if none of the above is defined\n"
	"	return vec3(1.0);\n"
	"}\n"
	"\n"
	"vec3 CrtsFilter(vec2 ipos, vec2 inputSizeDivOutputSize, vec2 halfInputSize, vec2 rcpInputSize, vec2 rcpOutputSize, vec2 twoDivOutputSize, float inputHeight, vec2 warp, float thin, float blur, float mask, vec4 tone) {\n"
	"	vec2 pos = ipos * twoDivOutputSize - vec2(1.0);\n"
	"	pos *= vec2(1.0 + (pos.y * pos.y) * warp.x, 1.0 + (pos.x * pos.x) * warp.y);\n"
	"	float vin = 1.0 - ((1.0 - CrtsSatF1(pos.x * pos.x)) * (1.0 - CrtsSatF1(pos.y * pos.y)));\n"
	"	vin = CrtsSatF1((-vin) * inputHeight + inputHeight);\n"
	"	pos = pos * halfInputSize + halfInputSize;\n"
	"\n"
	"	float y0 = floor(pos.y - 0.5) + 0.5;\n"
	"	float x0 = floor(pos.x - 1.5) + 0.5;\n"
	"	vec2 p = vec2(x0 * rcpInputSize.x, y0 * rcpInputSize.y);\n"
	"\n"
	"	vec3 colA[4], colB[4];\n"
	"	for(int i = 0; i < 4; i++) {\n"
	"		colA[i] = CrtsFetch(p);\n"
	"		p.x += rcpInputSize.x;\n"
	"	}\n"
	"	p.y += rcpInputSize.y;\n"
	"	for(int i = 3; i >= 0; i--) {\n"
	"		p.x -= rcpInputSize.x;\n"
	"		colB[i] = CrtsFetch(p);\n"
	"	}\n"
	"\n"
	"	float off = pos.y - y0;\n"
	"	float scanA = cos(min(HALF, off * thin) * PI2) * HALF + HALF;\n"
	"	float scanB = cos(min(HALF, (-off) * thin + thin) * PI2) * HALF + HALF;\n"
	"\n"
	"	float off0 = pos.x - x0;\n"
	"	float pix[4];\n"
	"	for(int i = 0; i < 4; i++) {\n"
	"		float diff = off0 - float(i);\n"
	"		pix[i] = exp2(blur * diff * diff);\n"
	"	}\n"
	"	float pixT = CrtsRcpF1(pix[0] + pix[1] + pix[2] + pix[3]);\n"
	"\n"
	"#ifdef CRTS_WARP\n"
	"	pixT *= vin;\n"
	"#endif\n"
	"\n"
	"	scanA *= pixT;\n"
	"	scanB *= pixT;\n"
	"\n"
	"	vec3 color = (colA[0] * pix[0] + colA[1] * pix[1] + colA[2] * pix[2] + colA[3] * pix[3]) * scanA + (colB[0] * pix[0] + colB[1] * pix[1] + colB[2] * pix[2] + colB[3] * pix[3]) * scanB;\n"
	"	color *= CrtsMask(ipos, mask);\n"
	"\n"
	"#ifdef CRTS_TONE\n"
	"	float peak = max(1.0 / (256.0 * 65536.0), CrtsMax3F1(color.r, color.g, color.b));\n"
	"	vec3 ratio = color * CrtsRcpF1(peak);\n"
	"#ifdef CRTS_CONTRAST\n"
	"	peak = pow(peak, tone.x);\n"
	"#endif\n"
	"	peak = peak * CrtsRcpF1(peak * tone.y + tone.z);\n"
	"#ifdef CRTS_SATURATION\n"
	"	ratio = pow(ratio, vec3(tone.w));\n"
	"#endif\n"
	"	return ratio * peak;\n"
	"#else\n"
	"	return color;\n"
	"#endif\n"
	"}\n"
	"\n"
	"void main() {\n"
	"	vec2 fragCoord = vec2(frag_texture_coord.x, 1.0 - frag_texture_coord.y);\n"
	"	fragCoord += 0.0001;\n"
	"	if(crt_emulation != 0) {\n"
	"		vec3 color = CrtsFilter(\n"
	"			fragCoord * resolution,\n"
	"			src_image_size / resolution,\n"
	"			src_image_size * 0.5,\n"
	"			1.0 / src_image_size,\n"
	"			1.0 / resolution,\n"
	"			2.0 / resolution,\n"
	"			src_image_size.y,\n"
	"			vec2(1.0 / 24.0, 1.0 / 16.0), // warp value\n"
	"			INPUT_THIN,\n"
	"			INPUT_BLUR,\n"
	"			INPUT_MASK,\n"
	"			tone_data\n"
	"		);\n"
	"\n"
	"		color *= brightness;\n"
	"\n"
	"		// Remap the range [bias, 1.0] to [0.0, 1.0] linearly\n"
	"		const float bias = 0.002;\n"
	"		color = bias + color * (1.0 - bias);\n"
	"\n"
	"		// Ensure no values fall below zero (important in case the subtraction went negative)\n"
	"		color = max(color, vec3(0.0));\n"
	"\n"
	"		frag_color = vec4(color, 1.0);\n"
	"	} else {\n"
	"		frag_color = vec4(texture(iChannel0, fragCoord).rgb, 1.0);\n"
	"	}\n"
	"}\n"
	"\n";

